From 11e528ffa4c256308b2a2081aa244b8440c12487 Mon Sep 17 00:00:00 2001
From: Patrick Ohly <patrick.ohly@intel.com>
Date: Fri, 24 Nov 2017 14:57:45 +0100
Subject: [PATCH 2/2] swupd verify: fix --picky, add --extra-picky +
 --picky-whitelist

The code implementing the suppression of /usr/lib/kernel,
/usr/lib/modules and /usr/local did a rather simplistic prefix
comparison with strncmp() to match path names against these
exceptions. As a result, paths like /usr/lib/kernel.old which should
get reported also got skipped.

An if check tested the wrong variable, so the result from strdup()
wasn't checked.

The replacement code uses regular expression matching and allows
removing (--picky-whitelist "") or replacing the
default (--picky-whitelist "^/ignore-this-top-level-dir/"). Because
regular expressions are used and directory path names that get matched
against include the trailing slash, it is possible to match
directories exactly as well as individual files. A single parameter is
enough when using the | operator.

Custom whitelists are needed for A/B partitioning when the partition
also contains the swupd state dir, because that should not be removed
by "swupd verify --fix".

The new --extra-picky does the same as --picky, it merely starts at
the root instead of /usr.

Fixes #336
Implements #239

Signed-off-by: Patrick Ohly <patrick.ohly@intel.com>
---
 include/swupd.h   |  3 ++-
 src/extra_files.c | 47 ++++++++++++++++++---------------
 src/verify.c      | 78 +++++++++++++++++++++++++++++++++++++++++++++----------
 3 files changed, 93 insertions(+), 35 deletions(-)

diff --git a/include/swupd.h b/include/swupd.h
index cae9b8f..eb47315 100644
--- a/include/swupd.h
+++ b/include/swupd.h
@@ -4,6 +4,7 @@
 #include <curl/curl.h>
 #include <dirent.h>
 #include <limits.h>
+#include <regex.h>
 #include <stdbool.h>
 #include <stdint.h>
 #include <stdio.h>
@@ -197,7 +198,7 @@ extern void increment_retries(int *retries, int *timeout);
 extern int main_update(void);
 extern int add_included_manifests(struct manifest *mom, int current, struct list **subs);
 extern int main_verify(int current_version);
-extern int walk_tree(struct manifest *, const char *, bool);
+extern int walk_tree(struct manifest *, const char *, bool, const regex_t *);
 
 extern int get_latest_version(void);
 extern void read_versions(int *current_version, int *server_version, char *path_prefix);
diff --git a/src/extra_files.c b/src/extra_files.c
index bd64568..e93b02d 100644
--- a/src/extra_files.c
+++ b/src/extra_files.c
@@ -45,14 +45,7 @@
 static struct filerecord *F; /* Array of filerecords */
 static int nF = 0;	   /* Number of filerecords */
 
-static struct fileskip {
-	const char *shortname; /* Without prefix */
-	char *name;	    /* full name, including any path_prefix */
-	int len;
-} skip_dirs[] =
-    { { shortname : "/lib/modules" },
-      { shortname : "/lib/kernel" },
-      { shortname : "/local" } };
+static const regex_t *path_whitelist;
 static int path_prefix_len;
 
 /* Helper function to call from nftw */
@@ -63,15 +56,34 @@ static inline int bsearch_helper(const void *A, const void *B)
 
 static int record_filename(const char *name, const struct stat *stat __attribute__((unused)), int type, struct FTW *ftw __attribute__((unused)))
 {
-	for (size_t i = 0; i < sizeof(skip_dirs) / sizeof(skip_dirs[0]); i++) {
-		if (strncmp(name, skip_dirs[i].name, skip_dirs[i].len) == 0) {
+	/* Name as it would appear in manifest, f.i. /usr */
+	const char *relname = name + path_prefix_len - 1;
+
+	if (!relname[0] || !strcmp(relname, "/")) {
+		/* Do not record root while descending into it. */
+		return 0;
+	}
+
+	if (path_whitelist) {
+		int match_res;
+		if (type == FTW_D) {
+			/* include trailing slash for regex like ^/var/ */
+			char *temp;
+			string_or_die(&temp, "%s/", relname);
+			match_res = regexec(path_whitelist, temp, 0, NULL, 0);
+			free(temp);
+		} else {
+			match_res = regexec(path_whitelist, relname, 0, NULL, 0);
+		}
+		if (match_res == 0) {
+			/* ignore matching entry and everything underneath it */
 			return FTW_SKIP_SUBTREE;
 		}
 	}
 
-	char *savedname = strdup(name + path_prefix_len - 1); /* Only store name relative to top of area */
+	char *savedname = strdup(relname); /* Only store name relative to top of area */
 	F = realloc(F, (nF + 1) * sizeof(*F));		      /* TODO, check realloc is smart, so don't need to double myself */
-	if (!F || !name) {
+	if (!F || !savedname) {
 		fprintf(stderr, "Out of memory allocating %d filenames\n", nF);
 		return -ENOMEM;
 	}
@@ -107,16 +119,12 @@ static void handle(const char *filename, bool is_dir, bool fix)
 }
 
 /* expect the start to end in /usr and be the absolute path to the root */
-int walk_tree(struct manifest *manifest, const char *start, bool fix)
+int walk_tree(struct manifest *manifest, const char *start, bool fix, const regex_t *whitelist)
 {
 	/* Walk the tree, */
 	int rc;
 	path_prefix_len = strlen(path_prefix);
-	/* Set up the directories to skip */
-	for (size_t i = 0; i < sizeof(skip_dirs) / sizeof(skip_dirs[0]); i++) {
-		skip_dirs[i].name = mk_full_filename(start, skip_dirs[i].shortname);
-		skip_dirs[i].len = strlen(skip_dirs[i].name);
-	}
+	path_whitelist = whitelist;
 	rc = nftw(start, &record_filename, 0, FTW_ACTIONRETVAL | FTW_PHYS | FTW_MOUNT);
 	const char *skip_dir = NULL; /* Skip files below this in printout */
 	if (rc) {
@@ -171,9 +179,6 @@ int walk_tree(struct manifest *manifest, const char *start, bool fix)
 	}
 	rc = nF;
 tidy:
-	for (size_t i = 0; i < sizeof(skip_dirs) / sizeof(skip_dirs[0]); i++) {
-		free(skip_dirs[i].name);
-	}
 	for (int i = 0; i < nF; i++) {
 		free(F[i].filename);
 	}
diff --git a/src/verify.c b/src/verify.c
index 4898e98..ca22a89 100644
--- a/src/verify.c
+++ b/src/verify.c
@@ -31,6 +31,7 @@
 #include <string.h>
 #include <sys/stat.h>
 #include <unistd.h>
+#include <regex.h>
 
 #include "config.h"
 #include "signature.h"
@@ -38,6 +39,10 @@
 
 static bool cmdline_option_fix = false;
 static bool cmdline_option_picky = false;
+static bool cmdline_option_extra_picky = false;
+static regex_t cmdline_option_picky_whitelist;
+static const char picky_whitelist_default[] = "^(/usr/lib/modules/|/usr/lib/kernel/|/usr/local/)";
+static bool cmdline_option_picky_whitelist_set = false;
 static bool cmdline_option_install = false;
 static bool cmdline_option_quick = false;
 
@@ -71,6 +76,8 @@ static const struct option prog_opts[] = {
 	{ "force", no_argument, 0, 'x' },
 	{ "nosigcheck", no_argument, 0, 'n' },
 	{ "picky", no_argument, 0, 'Y' },
+	{ "extra-picky", no_argument, 0, 'X' },
+	{ "picky-whitelist", required_argument, 0, 'w' },
 	{ "statedir", required_argument, 0, 'S' },
 	{ "certpath", required_argument, 0, 'C' },
 	{ "time", no_argument, 0, 't' },
@@ -93,7 +100,9 @@ static void print_help(const char *name)
 	fprintf(stderr, "   -c, --contenturl=[URL]  RFC-3986 encoded url for content file downloads\n");
 	fprintf(stderr, "   -v, --versionurl=[URL]  RFC-3986 encoded url for version file downloads\n");
 	fprintf(stderr, "   -f, --fix               Fix local issues relative to server manifest (will not modify ignored files)\n");
-	fprintf(stderr, "   -Y, --picky             List files which should not exist\n");
+	fprintf(stderr, "   -Y, --picky             List (without --fix) or remove (with --fix) files which should not exist (limited to /usr)\n");
+	fprintf(stderr, "   -X, --extra-picky       List (without --fix) or remove (with --fix) files which should not exist anywhere under /\n");
+	fprintf(stderr, "   -w, --picky-whitelist=re POSIX extended regular expression. Any file path matching the expression is ignored by --[extra-]picky. Matched directories get skipped completely. Empty regex matches nothing. Example: ^/var/|^/etc/machine-id$. Default: %s\n", picky_whitelist_default);
 	fprintf(stderr, "   -i, --install           Similar to \"--fix\" but optimized for install all files to empty directory\n");
 	fprintf(stderr, "   -F, --format=[staging,1,2,etc.]  the format suffix for version file downloads\n");
 	fprintf(stderr, "   -q, --quick             Don't compare hashes, only fix missing files\n");
@@ -111,7 +120,16 @@ static void print_help(const char *name)
 static bool parse_options(int argc, char **argv)
 {
 	int opt;
-
+	int errcode;
+
+	errcode = regcomp(&cmdline_option_picky_whitelist, picky_whitelist_default, REG_NOSUB|REG_EXTENDED);
+	cmdline_option_picky_whitelist_set = true;
+	if (errcode) {
+		char buffer[160];
+		regerror (errcode, &cmdline_option_picky_whitelist, buffer, sizeof(buffer));
+		fprintf(stderr, "Invalid default --picky-whitelist: %s\n\n", buffer);
+		goto err;
+	}
 	while ((opt = getopt_long(argc, argv, "hxnItNbm:p:u:P:c:v:fYiF:qS:C:", prog_opts, NULL)) != -1) {
 		switch (opt) {
 		case '?':
@@ -210,6 +228,31 @@ static bool parse_options(int argc, char **argv)
 		case 'Y':
 			cmdline_option_picky = true;
 			break;
+		case 'X':
+			cmdline_option_extra_picky = true;
+			break;
+		case 'w':
+			if (!optarg) {
+				fprintf(stderr, "Missing --picky-whitelist argument\n\n");
+				goto err;
+			}
+			if (cmdline_option_picky_whitelist_set) {
+				regfree(&cmdline_option_picky_whitelist);
+			}
+			if (*optarg) {
+				errcode = regcomp(&cmdline_option_picky_whitelist, optarg, REG_NOSUB|REG_EXTENDED);
+				cmdline_option_picky_whitelist_set = true;
+				if (errcode) {
+					char buffer[160];
+					regerror (errcode, &cmdline_option_picky_whitelist, buffer, sizeof(buffer));
+					fprintf(stderr, "Invalid --picky-whitelist argument: %s\n\n", buffer);
+					goto err;
+				}
+			} else {
+				/* unset previous or default whitelist */
+				cmdline_option_picky_whitelist_set = false;
+			}
+			break;
 		default:
 			fprintf(stderr, "Unrecognized option\n\n");
 			goto err;
@@ -675,7 +718,8 @@ int verify_main(int argc, char **argv)
 	copyright_header("software verify");
 
 	if (!parse_options(argc, argv)) {
-		return EINVALID_OPTION;
+		ret = EINVALID_OPTION;
+		goto clean_args_and_exit;
 	}
 
 	/* parse command line options */
@@ -773,14 +817,14 @@ int verify_main(int argc, char **argv)
 	/* If --fix was specified but --force and --picky are not present, check
 	 * that the user is only fixing to their current version. If they are
 	 * fixing to a different version, print an error message that they need to
-	 * specify --force or --picky. */
+	 * specify --force or --[extra-]picky. */
 	if (cmdline_option_fix && !is_current_version(version)) {
-		if (cmdline_option_picky || force) {
+		if (cmdline_option_picky || cmdline_option_extra_picky || force) {
 			fprintf(stderr, "WARNING: the force or picky option is specified; "
 					"ignoring version mismatch for verify --fix\n");
 		} else {
 			fprintf(stderr, "ERROR: Fixing to a different version requires "
-					"--force or --picky\n");
+					"--force or --picky or --extra-picky\n");
 			ret = EMANIFEST_LOAD;
 			goto clean_and_exit;
 		}
@@ -867,10 +911,11 @@ load_submanifests:
 		if ((file_not_fixed_count == 0) && (file_not_replaced_count == 0)) {
 			remove_orphaned_files(official_manifest);
 		}
-		if (cmdline_option_picky) {
-			char *start = mk_full_filename(path_prefix, "/usr");
-			fprintf(stderr, "--picky removing extra files under %s\n", start);
-			ret = walk_tree(official_manifest, start, true);
+		if (cmdline_option_picky || cmdline_option_extra_picky) {
+			char *start = mk_full_filename(path_prefix, cmdline_option_extra_picky ? "" : "/usr");
+			fprintf(stderr, "%s removing extra files under %s\n", cmdline_option_extra_picky ? "--extra-picky" : "--picky", start);
+			ret = walk_tree(official_manifest, start, true,
+					cmdline_option_picky_whitelist_set ? &cmdline_option_picky_whitelist : NULL);
 			if (ret >= 0) {
 				file_checked_count = ret;
 				ret = 0;
@@ -878,10 +923,11 @@ load_submanifests:
 			free(start);
 		}
 		grabtime_stop(&times);
-	} else if (cmdline_option_picky) {
-		char *start = mk_full_filename(path_prefix, "/usr");
+	} else if (cmdline_option_picky || cmdline_option_extra_picky) {
+		char *start = mk_full_filename(path_prefix, cmdline_option_extra_picky ? "" : "/usr");
 		fprintf(stderr, "Generating list of extra files under %s\n", start);
-		ret = walk_tree(official_manifest, start, false);
+		ret = walk_tree(official_manifest, start, false,
+				cmdline_option_picky_whitelist_set ? &cmdline_option_picky_whitelist : NULL);
 		if (ret >= 0) {
 			file_checked_count = ret;
 			ret = 0;
@@ -994,5 +1040,11 @@ clean_and_exit:
 	print_time_stats(&times);
 	swupd_deinit(lock_fd, &subs);
 
+clean_args_and_exit:
+	if (cmdline_option_picky_whitelist_set) {
+		regfree(&cmdline_option_picky_whitelist);
+		cmdline_option_picky_whitelist_set = false;
+	}
+
 	return ret;
 }
-- 
2.11.0

